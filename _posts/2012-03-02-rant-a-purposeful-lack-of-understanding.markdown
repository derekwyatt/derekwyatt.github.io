---
layout: post
title: Rant - A Purposeful Lack of Understanding
header-img: img/old-bridge.png
tags:
- blog
---
I recently responded to someone's question on [StackOverflow](http://stackoverflow.com) and now I have to rant about something.

There is a large problem I find with programmers that I meet (generally in Real Life, as opposed to on the 'net because on the 'net I associate with passionate programmers) when it comes to learning new "stuff". The first thing they do is try to draw it close to something they already understand. For example, they pick up [Python](http://python.org) and try to relate it to something like [Java](http://http://www.oracle.com/technetwork/java/index.html). This is not a problem.

The problem comes from the fact that it's not just the *first* thing they do, it's also the *last* thing they do. Why is this a problem? Oh for so many reasons...

### It's *new*

Relating this 'new' thing to something you are familiar with is vital in the first stages in order to get a foothold on a new experience. But once you've got that, you need to *forget it*.

Let's take a new language as an example. If you're a Java coder and you've never coded in [Ruby](http://www.ruby-lang.org/) before, then when you see Ruby you're going to be looking for *objects*. This is all well and good, and it gets you into the language so you can start expressing your ideas. Awesome. But if Ruby was just a scripted Java then it wouldn't have a lot of use, would it?

What you're going to miss with Ruby (among about a million other things) is that Ruby is very much about *functions* and not so much about *objects* (Ok, I don't want to get in a big debate with people here... I get it, it's about objects too... and a lot of other stuff). And missing this means you're going to miss out on a solid opportunity to enhance the way you *think* about designing and writing software.

Languages are not nearly as important as the paradigms they help you express. All we do for a living is *think* and the better you can think about your problems and their solutions, the better you are at what you do.

### It's *not that other thing...*

If the "other thing" you're used to is worth anything at all, then it's going to have some "good points" to it - it damn well better have. The "new thing" is going to have good points too, and they're going to be different than those in your wheel house. If you're used to feature **X**, chances are you're not going to see feature **X** in this new thing. Why? *It's not that other thing*. Seems obvious, right? If it's so obvious then why do I see so many people not getting it?

Here's an example. There's a colleague of mine that loves [Erlang](http://www.erlang.org/) - great language, and it's awesome to love it. When talking about [Akka](http://akka.io), he asked me whether or not you could [hibernate](http://http://www.erlang.org/doc/man/erlang.html#hibernate-3) an Actor (closest equivalent to an Erlang 'process' as far as our discussion went). I said "no". I was immediately met with statements like, *"It **must** have that or it's no good,"* and stuff like that. What he didn't grasp, until explained, was that Akka is modeled completely differently and has no *need* of the hibernate functionality. This is a fundamental difference between the two designs - and there are definite trade-offs being made for many different reasons. The point I'm making here is that, unless I explained it, he would have written off the technology based on a fabricated fantasy.

If you expect a new thing to be exactly the same as the old thing, then why would you look at the new thing? *It's not that other thing!*

### It misses the whole point

I've already said this earlier but it's a very general idea. How many ways are there to solve problems in our industry? It's pretty much infinite, right? I can select any language I want, for starters. I can then choose any tool within that language, or I can choose another language and bolt that on to help solve the problem. I can use existing programs or libraries from anywhere else to do it. And I haven't even started coding yet. Once I start coding, I can code in nearly any paradigm I want to, or any hybrid set of paradigms that I want to (made easier by a multi-paradigm language of course).

So, let me ask you this: If all you know is one language, and one set of tools, and you view every other language and every other tool through the foggy lens of "what you already know", then how many ways are there to solve problems when *you're* the one solving it? Not many, right? You'll probably come up with solutions, but if they suck, you're stuck - you have no other tools in your head to help solve these things. You're stuck with sucking. Not awesome.

The whole point of learning new things is to *learn new things*. Please, if you find yourself looking at something and scoffing and saying "Well, it's not like this other thing that I'm comfortable with", then say "GREAT!" *If you find yourself outside your comfort zone then you're doing it right.*

If it were comfortable and familiar then you wouldn't be learning, and if you're not learning, then stop what you're doing and go back to doing something productive with what you already know. Save that time for finding something to learn that you're really not comfortable with.
